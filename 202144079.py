# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XpCMjxkg3w547ZuGlMsgwADlRNFulm9e
"""

# Colab ì½”ë“œ ì‹¤í–‰ 1/4: ë°ì´í„° ë¡œë“œ ë° ì‹œê³„ì—´ íŠ¹ì§• ìƒì„± (ì¸ì½”ë”© ìˆ˜ì • ë²„ì „)

import pandas as pd
import numpy as np
import json
import os
from datetime import timedelta

# --- 1. íŒŒì¼ ê²½ë¡œ ì •ì˜ ë° ë¡œë“œ ---
MAIN_DATA_PATH = "19_24_drunk.csv"
print("--- 1. ë°ì´í„° ë¡œë“œ ì‹œì‘ ---")

try:
    # âš ï¸ ì¸ì½”ë”©ì„ 'cp949'ë¡œ ìˆ˜ì • (UTF-8 ë””ì½”ë”© ì˜¤ë¥˜ í•´ê²°)
    drunk_df = pd.read_csv(MAIN_DATA_PATH, encoding='cp949', sep=',')
    print(f"âœ… ë©”ì¸ ì‚¬ê³  ë°ì´í„° ë¡œë“œ ì„±ê³µ: ì´ {len(drunk_df)}ê±´")
except FileNotFoundError:
    print(f"âŒ ì˜¤ë¥˜: '{MAIN_DATA_PATH}' íŒŒì¼ì„ Colabì— ì—…ë¡œë“œí–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
    drunk_df = pd.DataFrame()
except Exception as e:
    # cp949ë„ ì‹¤íŒ¨í•  ê²½ìš° (ë§¤ìš° ë“œë¬¼ì§€ë§Œ)
    print(f"âŒ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
    drunk_df = pd.DataFrame()

if not drunk_df.empty:

    # --- 2. ê¸°ë³¸ ì „ì²˜ë¦¬ ë° ì—°ë„ íŠ¹ì§• ì¶”ì¶œ ---
    print("\n--- 2. ê¸°ë³¸ ì „ì²˜ë¦¬ ë° ì—°ë„ íŠ¹ì§• ì¶”ì¶œ ---")

    # 'ì‚¬ê³ ë‹¤ë°œì§€id'ì—ì„œ ì—°ë„ ì¶”ì¶œ (ì˜ˆ: 2022051 -> 2022)
    drunk_df['ì‚¬ê³ ì—°ë„'] = drunk_df['ì‚¬ê³ ë‹¤ë°œì§€id'].astype(str).str[:4].astype(int)

    # 'ì‹œë„ì‹œêµ°êµ¬ëª…' ì»¬ëŸ¼ ë¶„ë¦¬ (ì˜ˆ: 'ì„œìš¸íŠ¹ë³„ì‹œ ì¢…ë¡œêµ¬1' -> 'ì„œìš¸íŠ¹ë³„ì‹œ', 'ì¢…ë¡œêµ¬')
    drunk_df[['ì‹œë„ëª…', 'êµ¬êµ°ëª…']] = drunk_df['ì‹œë„ì‹œêµ°êµ¬ëª…'].str.split(' ', n=1, expand=True)
    drunk_df['êµ¬êµ°ëª…'] = drunk_df['êµ¬êµ°ëª…'].str.replace(r'\d+$', '', regex=True).str.strip()

    print(f"âœ… 'ì‚¬ê³ ì—°ë„', 'ì‹œë„ëª…', 'êµ¬êµ°ëª…' ì¶”ì¶œ ì™„ë£Œ.")

    # --- 3. ì‹œê³„ì—´ íŠ¹ì§• ê³µí•™ (Temporal Feature Engineering) ---
    print("\n--- 3. ì‹œê³„ì—´ íŠ¹ì§• ê³µí•™ (ì‹œê°„ ì •ë³´ ì‹œë®¬ë ˆì´ì…˜) ---")

    # ğŸš¨ğŸš¨ğŸš¨ ì¤‘ìš”: 'ì‚¬ê³ ì¼ì‹œ' ì»¬ëŸ¼ ì‹œë®¬ë ˆì´ì…˜ ğŸš¨ğŸš¨ğŸš¨
    np.random.seed(42)

    start_time = pd.to_datetime('2019-01-01')
    time_range_seconds = (pd.to_datetime('2024-12-31') - start_time).total_seconds()
    random_seconds = np.random.randint(0, time_range_seconds, size=len(drunk_df))
    drunk_df['ì‚¬ê³ ì¼ì‹œ'] = start_time + pd.to_timedelta(random_seconds, unit='s')

    print(f"âœ… 'ì‚¬ê³ ì¼ì‹œ' ì»¬ëŸ¼ ì„ì‹œ ìƒì„± ì™„ë£Œ.")

    # 3-1. ìš”ì¼ ë° ì£¼ë§/ì£¼ì¤‘ êµ¬ë¶„
    drunk_df['ìš”ì¼'] = drunk_df['ì‚¬ê³ ì¼ì‹œ'].dt.dayofweek # 0:ì›”, 6:ì¼
    drunk_df['ì£¼ë§_ì—¬ë¶€'] = drunk_df['ìš”ì¼'].apply(lambda x: 1 if x >= 5 else 0) # í† /ì¼ = 1 (ì£¼ë§)

    # 3-2. ì‹œê°„ëŒ€(í”¼í¬íƒ€ì„) íŠ¹ì§• ì¶”ì¶œ
    drunk_df['ì‹œê°„ëŒ€'] = drunk_df['ì‚¬ê³ ì¼ì‹œ'].dt.hour

    # ìŒì£¼ìš´ì „ ìœ„í—˜ í”¼í¬ ì‹œê°„ëŒ€ ë¶„ë¥˜ (22ì‹œ ~ ìƒˆë²½ 4ì‹œë¥¼ ê³ ìœ„í—˜ìœ¼ë¡œ ì„¤ì •)
    def classify_peak_time(hour):
        if 22 <= hour or hour <= 4:
            return 'ì‹¬ì•¼/ìƒˆë²½_í”¼í¬'
        elif 18 <= hour < 22:
            return 'ì €ë…_í”¼í¬'
        else:
            return 'ì£¼ê°„/ë¹„í”¼í¬'

    drunk_df['ìœ„í—˜_ì‹œê°„ëŒ€_ê·¸ë£¹'] = drunk_df['ì‹œê°„ëŒ€'].apply(classify_peak_time)

    # --- 4. ì¤‘ê°„ ê²°ê³¼ ì €ì¥ ---
    # ë‹¤ìŒ ë‹¨ê³„(ê³µê°„ íŠ¹ì§• ê³µí•™)ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì €ì¥í•©ë‹ˆë‹¤.
    drunk_df.to_pickle("processed_part1_df.pkl")
    print("\nâœ… Part 1 ì™„ë£Œ. ì¤‘ê°„ ê²°ê³¼ê°€ 'processed_part1_df.pkl'ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")

# Colab ì½”ë“œ ì‹¤í–‰ 2/4: ê³µê°„ íŠ¹ì§• ìƒì„±

import pandas as pd
import numpy as np
import json
# Colab í™˜ê²½ì—ì„œ shapely ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ê¸°ë³¸ìœ¼ë¡œ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
from shapely.geometry import Polygon
from math import radians, sin, cos, sqrt, atan2

# --- 1. Part 1 ê²°ê³¼ ë¡œë“œ ---
try:
    df = pd.read_pickle("processed_part1_df.pkl")
    print("âœ… Part 1 ê²°ê³¼ ë¡œë“œ ì„±ê³µ.")
except FileNotFoundError:
    print("âŒ ì˜¤ë¥˜: 'processed_part1_df.pkl' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Part 1 ì½”ë“œë¥¼ ë¨¼ì € ì‹¤í–‰í•´ì£¼ì„¸ìš”.")
    df = pd.DataFrame()

if not df.empty:

    print("\n--- 2. ê³µê°„ íŠ¹ì§• ê³µí•™ ì‹œì‘ ---")

    # 2-1. ìœ„ë„/ê²½ë„ ë°ì´í„° íƒ€ì… ë³€í™˜ ë° ê²°ì¸¡ì¹˜ ì²˜ë¦¬
    df['ê²½ë„'] = pd.to_numeric(df['ê²½ë„'], errors='coerce')
    df['ìœ„ë„'] = pd.to_numeric(df['ìœ„ë„'], errors='coerce')
    df.dropna(subset=['ê²½ë„', 'ìœ„ë„'], inplace=True)
    print(f"âœ… ê²½ë„/ìœ„ë„ ê²°ì¸¡ì¹˜ ì²˜ë¦¬ ì™„ë£Œ. (ë‚¨ì€ ë°ì´í„°: {len(df)}ê±´)")


    # 2-2. íŠ¹ì§• 1: ë‹¤ë°œì§€ì—­ í´ë¦¬ê³¤ ë©´ì  ê³„ì‚° (ì§€ë¦¬ì  í¬ê¸° íŠ¹ì§•)
    def calculate_polygon_area(json_str):
        """ë‹¤ë°œì§€ì—­ í´ë¦¬ê³¤ JSON ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ ë©´ì (m^2)ì„ ì¶”ì •í•©ë‹ˆë‹¤."""
        try:
            data = json.loads(json_str)
            coords = data['coordinates'][0]
            polygon = Polygon(coords)
            # WGS84 ì¢Œí‘œê³„ì—ì„œì˜ ë©´ì ì„ m^2ìœ¼ë¡œ ëŒ€ëµ í™˜ì‚° (íŠ¹ì§•ìœ¼ë¡œ í™œìš©)
            # 1ë„ ê²½ë„/ìœ„ë„ë‹¹ ëŒ€ëµ 111kmì´ë¯€ë¡œ (111000m)^2ì„ ê³±í•˜ì—¬ ê·¼ì‚¬ì¹˜ ê³„ì‚°
            return polygon.area * (111000**2)
        except Exception:
            return 0.0

    df['í´ë¦¬ê³¤_ë©´ì _m2'] = df['ë‹¤ë°œì§€ì—­í´ë¦¬ê³¤'].apply(calculate_polygon_area)
    print("âœ… íŠ¹ì§• 1: 'í´ë¦¬ê³¤_ë©´ì _m2' ìƒì„± ì™„ë£Œ.")


    # 2-3. íŠ¹ì§• 2: ê³µê°„ ë°€ì§‘ë„ ì§€ìˆ˜ (ìµœê·¼ì ‘ ë‹¤ë°œì§€ì—­ ê±°ë¦¬) ê³„ì‚°

    # Haversine ê³µì‹ (ë‘ ì§€ì  ê°„ ê±°ë¦¬(km) ê³„ì‚°)
    def haversine(lat1, lon1, lat2, lon2):
        R = 6371  # ì§€êµ¬ ë°˜ì§€ë¦„ (km)
        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def find_nearest_distance(row, df):
        """ê°€ì¥ ê°€ê¹Œìš´ ë‹¤ë°œì§€ì—­ê¹Œì§€ì˜ ê±°ë¦¬(km)ë¥¼ ì°¾ìŠµë‹ˆë‹¤. (ìê¸° ìì‹  ì œì™¸)"""
        distances = []
        # ìê¸° ìì‹ ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ë°ì´í„°
        other_locations = df[df.index != row.name]

        # NOTE: ëŒ€ê·œëª¨ ë°ì´í„°ì…‹ì—ì„œëŠ” ì´ ê³„ì‚°ì´ ë§¤ìš° ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ,
        # ì‹¤ì „ì—ì„œëŠ” K-D Treeë‚˜ Geohashë¥¼ ì‚¬ìš©í•œ ìµœì í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # ì—¬ê¸°ì„œëŠ” ì •í™•í•œ íŠ¹ì§•ê°’ ê³„ì‚°ì„ ìœ„í•´ ì „ì²´ ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
        for index, other_row in other_locations.iterrows():
            dist = haversine(row['ìœ„ë„'], row['ê²½ë„'], other_row['ìœ„ë„'], other_row['ê²½ë„'])
            distances.append(dist)

        return min(distances) if distances else 0.0

    print("\nâ³ íŠ¹ì§• 2: 'ìµœê·¼ì ‘_ë‹¤ë°œì§€ì—­_ê±°ë¦¬_km' ê³„ì‚° ì¤‘...")
    df['ìµœê·¼ì ‘_ë‹¤ë°œì§€ì—­_ê±°ë¦¬_km'] = df.apply(
        lambda row: find_nearest_distance(row, df), axis=1
    )
    print("âœ… íŠ¹ì§• 2: 'ìµœê·¼ì ‘_ë‹¤ë°œì§€ì—­_ê±°ë¦¬_km' ê³„ì‚° ì™„ë£Œ.")


    # --- 3. ìµœì¢… ë°ì´í„° ì €ì¥ ---
    # ëª¨ë“  íŠ¹ì§• ê³µí•™ì´ ì™„ë£Œëœ ìµœì¢… ë°ì´í„°í”„ë ˆì„ ì €ì¥
    df.to_pickle("final_processed_df.pkl")

    print("\n--- Part 2 ìµœì¢… ê²°ê³¼ í™•ì¸ (ìƒìœ„ 5ê°œ í–‰) ---")
    print(df[['ì‚¬ê³ ê±´ìˆ˜', 'í´ë¦¬ê³¤_ë©´ì _m2', 'ìµœê·¼ì ‘_ë‹¤ë°œì§€ì—­_ê±°ë¦¬_km', 'ìœ„í—˜_ì‹œê°„ëŒ€_ê·¸ë£¹']].head())
    print("\nâœ… 1ë‹¨ê³„ íŠ¹ì§• ê³µí•™ ì™„ë£Œ. ìµœì¢… ë°ì´í„°ê°€ 'final_processed_df.pkl'ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")

# Colab ì½”ë“œ ì‹¤í–‰ 3/4: ëª¨ë¸ë§ ì¤€ë¹„ (ì¸ì½”ë”© ë° ë°ì´í„° ë¶„í• )

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# --- 1. ìµœì¢… ì „ì²˜ë¦¬ëœ ë°ì´í„° ë¡œë“œ ---
try:
    df = pd.read_pickle("final_processed_df.pkl")
    print("âœ… 'final_processed_df.pkl' ë¡œë“œ ì„±ê³µ.")
except FileNotFoundError:
    print("âŒ ì˜¤ë¥˜: 'final_processed_df.pkl' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Part 2 ì½”ë“œë¥¼ ë¨¼ì € ì‹¤í–‰í•´ì£¼ì„¸ìš”.")
    df = pd.DataFrame()

if not df.empty:

    # --- 2. ëª©í‘œ ë³€ìˆ˜(Target Y) ì •ì˜: ìœ„í—˜ ë“±ê¸‰ ë¶„ë¥˜ ---
    print("\n--- 2. ëª©í‘œ ë³€ìˆ˜(Target Y) ì •ì˜: ì‚¬ê³ ê±´ìˆ˜ -> ìœ„í—˜ ë“±ê¸‰ ë¶„ë¥˜ ---")

    # ì‚¬ê³ ê±´ìˆ˜ì˜ ë¶„ìœ„ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ„í—˜ ë“±ê¸‰ ê²½ê³„ ì„¤ì • (3ë¶„ìœ„ìˆ˜ ì‚¬ìš©)
    # Q1 (33% ê²½ê³„), Q2 (66% ê²½ê³„)
    quantiles = df['ì‚¬ê³ ê±´ìˆ˜'].quantile([0.33, 0.66]).tolist()
    q1, q2 = quantiles[0], quantiles[1]

    def classify_risk(count):
        if count >= q2:
            return 2 # 'ê³ ìœ„í—˜' (High Risk)
        elif count >= q1:
            return 1 # 'ì¤‘ìœ„í—˜' (Medium Risk)
        else:
            return 0 # 'ì €ìœ„í—˜' (Low Risk)

    df['ìœ„í—˜_ë“±ê¸‰'] = df['ì‚¬ê³ ê±´ìˆ˜'].apply(classify_risk)

    print(f"âœ… ìœ„í—˜ ë“±ê¸‰ ë¶„ë¥˜ ê¸°ì¤€: Q1({q1:.2f}), Q2({q2:.2f})")
    print("âœ… ìœ„í—˜ ë“±ê¸‰ ë¶„í¬:\n{}".format(df['ìœ„í—˜_ë“±ê¸‰'].value_counts()))


    # --- 3. íŠ¹ì§•(Feature X) ë° ëª©í‘œ ë³€ìˆ˜ ë¶„ë¦¬ ---
    features = [
        'ì‚¬ê³ ì—°ë„', 'ì£¼ë§_ì—¬ë¶€', 'ìœ„í—˜_ì‹œê°„ëŒ€_ê·¸ë£¹',
        'ê²½ë„', 'ìœ„ë„', 'í´ë¦¬ê³¤_ë©´ì _m2',
        'ìµœê·¼ì ‘_ë‹¤ë°œì§€ì—­_ê±°ë¦¬_km', 'ì‹œë„ëª…', 'êµ¬êµ°ëª…'
    ]

    X = df[features]
    Y = df['ìœ„í—˜_ë“±ê¸‰']


    # --- 4. ë²”ì£¼í˜• íŠ¹ì§• ì›-í•« ì¸ì½”ë”© (One-Hot Encoding) ---
    print("\n--- 4. ë²”ì£¼í˜• íŠ¹ì§• ì›-í•« ì¸ì½”ë”© ì‹œì‘ ---")

    # ì›-í•« ì¸ì½”ë”©ì„ ì ìš©í•  ë²”ì£¼í˜• ì»¬ëŸ¼ ì •ì˜
    categorical_cols = ['ìœ„í—˜_ì‹œê°„ëŒ€_ê·¸ë£¹', 'ì‹œë„ëª…', 'êµ¬êµ°ëª…']

    # One-Hot Encoding ì ìš© (ë‹¤ì¤‘ê³µì„ ì„± ë°©ì§€ë¥¼ ìœ„í•´ drop_first=True)
    X_encoded = pd.get_dummies(X, columns=categorical_cols, drop_first=True)

    print(f"âœ… ì›-í•« ì¸ì½”ë”© ì™„ë£Œ. íŠ¹ì§• ìˆ˜ ì¦ê°€: {X.shape[1]} -> {X_encoded.shape[1]}")

    # --- 5. ë°ì´í„° ë¶„í•  (í›ˆë ¨/í…ŒìŠ¤íŠ¸) ---
    print("\n--- 5. ë°ì´í„° ë¶„í•  (Train/Test Split) ---")

    # Stratify=Y ì˜µì…˜ì„ ì‚¬ìš©í•˜ì—¬ ìœ„í—˜ ë“±ê¸‰ì˜ ë¹„ìœ¨ì´ í›ˆë ¨/í…ŒìŠ¤íŠ¸ ì„¸íŠ¸ì— ë™ì¼í•˜ê²Œ ë¶„í¬ë˜ë„ë¡ í•©ë‹ˆë‹¤.
    X_train, X_test, Y_train, Y_test = train_test_split(
        X_encoded, Y, test_size=0.2, random_state=42, stratify=Y
    )

    # --- 6. ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìœ„í•´ ë°ì´í„° ì €ì¥ ---
    X_train.to_pickle("X_train.pkl")
    X_test.to_pickle("X_test.pkl")
    Y_train.to_pickle("Y_train.pkl")
    Y_test.to_pickle("Y_test.pkl")

    print(f"âœ… ë°ì´í„° ë¶„í•  ì™„ë£Œ. í›ˆë ¨ ì„¸íŠ¸ í¬ê¸°: {len(X_train)}ê±´")
    print("âœ… ëª¨ë¸ë§ ì¤€ë¹„ ì™„ë£Œ. í›ˆë ¨/í…ŒìŠ¤íŠ¸ ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")

import pandas as pd
import numpy as np
import os
import re # ì •ê·œí‘œí˜„ì‹ ì‚¬ìš©ì„ ìœ„í•´ import ì¶”ê°€

# =================================================================
# Part 4: ì‹œë„/êµ¬êµ° ì½”ë“œ ë¡œë“œ, ì •ë¦¬ ë° ë³‘í•© (Excel Sheet ì‚¬ìš©)
# =================================================================

print("\n--- 4. ì‹œë„/êµ¬êµ° ì½”ë“œ ë¡œë“œ ë° ì •ë¦¬ ì‹œì‘ (Excel Sheet ì‚¬ìš©) ---")

# 1. ëŸ°íƒ€ì„ ì¬ì‹œì‘ìœ¼ë¡œ ì‚¬ë¼ì§„ dfë¥¼ pickle íŒŒì¼ì—ì„œ ë‹¤ì‹œ ë¡œë“œ
try:
    df = pd.read_pickle("final_processed_df.pkl")
    print("âœ… 'final_processed_df.pkl' ë¡œë“œ ì„±ê³µ. (df ë³€ìˆ˜ ì¬ì •ì˜)")
except FileNotFoundError:
    print("âŒ ì˜¤ë¥˜: 'final_processed_df.pkl' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ì „ Part ì½”ë“œë¥¼ ë¨¼ì € ì‹¤í–‰í•´ ì£¼ì„¸ìš”.")
    df = pd.DataFrame()
    if df.empty:
        raise NameError("ë©”ì¸ ë°ì´í„°í”„ë ˆì„(df)ì„ ë¡œë“œí•  ìˆ˜ ì—†ì–´ ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤. ì´ì „ ë‹¨ê³„ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•´ ì£¼ì„¸ìš”.")
except Exception as e:
    print(f"âŒ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
    raise NameError("ë©”ì¸ ë°ì´í„°í”„ë ˆì„(df) ë¡œë“œ ì‹¤íŒ¨ë¡œ ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.")


# ğŸš¨ğŸš¨ğŸš¨ í•µì‹¬ ìˆ˜ì •: ë‹¨ì¼ Excel íŒŒì¼ê³¼ Sheet Name ì‚¬ìš© ğŸš¨ğŸš¨ğŸš¨
CODE_FILE = 'AccidentHazard_CodeList.xlsx'
SIDO_SHEET = 'Sido ìš”ì²­ê°’'
GUGUN_SHEET = 'Gugun ìš”ì²­ê°’'

# ì‹œë„ëª… í‘œì¤€í™” ë§µí•‘ (ê¸¸ì´ ê¸´ ì´ë¦„ -> ì§§ì€ ì´ë¦„)
sido_std_mapping = {
    'ì„œìš¸íŠ¹ë³„ì‹œ': 'ì„œìš¸', 'ë¶€ì‚°ê´‘ì—­ì‹œ': 'ë¶€ì‚°', 'ëŒ€êµ¬ê´‘ì—­ì‹œ': 'ëŒ€êµ¬', 'ì¸ì²œê´‘ì—­ì‹œ': 'ì¸ì²œ',
    'ê´‘ì£¼ê´‘ì—­ì‹œ': 'ê´‘ì£¼', 'ëŒ€ì „ê´‘ì—­ì‹œ': 'ëŒ€ì „', 'ìš¸ì‚°ê´‘ì—­ì‹œ': 'ìš¸ì‚°', 'ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ': 'ì„¸ì¢…',
    'ê²½ê¸°ë„': 'ê²½ê¸°', 'ê°•ì›íŠ¹ë³„ìì¹˜ë„': 'ê°•ì›', 'ê°•ì›ë„': 'ê°•ì›', 'ì¶©ì²­ë¶ë„': 'ì¶©ë¶',
    'ì¶©ì²­ë‚¨ë„': 'ì¶©ë‚¨', 'ì „ë¼ë¶ë„': 'ì „ë¶', 'ì „ë¼ë‚¨ë„': 'ì „ë‚¨', 'ê²½ìƒë¶ë„': 'ê²½ë¶',
    'ê²½ìƒë‚¨ë„': 'ê²½ë‚¨', 'ì œì£¼íŠ¹ë³„ìì¹˜ë„': 'ì œì£¼'
}

# â­â­â­ êµ¬êµ°ëª… í‘œì¤€í™” í•¨ìˆ˜ ìˆ˜ì • (ê°€ì¥ ì„¸ë¶€ì ì¸ êµ¬/êµ°/ì‹œ ëª…ì¹­ë§Œ ì¶”ì¶œ) â­â­â­
# 'ìˆ˜ì›ì‹œ ê¶Œì„ êµ¬' -> 'ê¶Œì„ êµ¬' ì²˜ëŸ¼ ê°€ì¥ ì„¸ë¶€ì ì¸ í–‰ì •êµ¬ì—­ ëª…ì¹­ë§Œ ë‚¨ê¹ë‹ˆë‹¤.
def standardize_gugun(gugun_name):
    gugun_name = str(gugun_name).strip()

    # 1. ê´„í˜¸ì™€ ê·¸ ë‚´ìš© ì œê±° (ì˜ˆ: 'ìˆ˜ì›ì‹œ(ì¥ì•ˆêµ¬)' -> 'ìˆ˜ì›ì‹œ')
    gugun_name = gugun_name.split('(')[0].strip()

    # 2. 'ì‹œ' + 'êµ¬' í˜•íƒœì—ì„œ 'êµ¬'ë§Œ ì¶”ì¶œ (ì˜ˆ: 'ìˆ˜ì›ì‹œ ê¶Œì„ êµ¬' -> 'ê¶Œì„ êµ¬')
    # ë‹¨, 'êµ°' ë˜ëŠ” 'ì‹œ'ê°€ ë‹¨ë…ìœ¼ë¡œ ë‚˜ì˜¤ëŠ” ê²½ìš°ëŠ” ì œì™¸
    parts = gugun_name.split()
    if len(parts) > 1 and parts[-1].endswith(('êµ¬', 'êµ°', 'ì', 'ë©´', 'ë™', 'ê°€', 'ë¡œ', 'ê¸¸')):
        # ê°€ì¥ ë§ˆì§€ë§‰ì˜ ì„¸ë¶€ í–‰ì •êµ¬ì—­ ëª…ì¹­ì„ ì‚¬ìš© (ì˜ˆ: 'ìˆ˜ì›ì‹œ ê¶Œì„ êµ¬' -> 'ê¶Œì„ êµ¬')
        return parts[-1]

    # 3. ê·¸ ì™¸ (ì˜ˆ: 'ìˆ˜ì›ì‹œ', 'ì² ì›êµ°' ë“±)
    return gugun_name

# -------------------------------------------------------------------------
# íŒŒì¼ ë¡œë“œ ë° ì •ë¦¬ (ì´ì „ ë¡œì§ ìœ ì§€)
# -------------------------------------------------------------------------

if not os.path.exists(CODE_FILE):
    print(f"âŒ ì˜¤ë¥˜: '{CODE_FILE}' íŒŒì¼ì„ Colabì— ì—…ë¡œë“œí–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
    df_sido_code = pd.DataFrame(columns=['ì‹œë„ëª…_std', 'sido_cd'])
    df_gugun_code = pd.DataFrame(columns=['ì‹œë„_std', 'êµ¬êµ°ëª…_std', 'gugun_cd'])
else:
    # 2. ì‹œë„ ì½”ë“œ (Sheet 1) ë¡œë“œ ë° ì •ë¦¬
    try:
        df_sido_code = pd.read_excel(CODE_FILE, sheet_name=SIDO_SHEET, header=None)
        df_sido_code = df_sido_code.iloc[1:][[0, 1]].copy()
        df_sido_code.columns = ['ì‹œë„ëª…_raw', 'sido_cd']

        df_sido_code = df_sido_code.dropna(subset=['sido_cd'])
        df_sido_code['sido_cd'] = df_sido_code['sido_cd'].astype(str).str.strip()
        df_sido_code['ì‹œë„ëª…_raw'] = df_sido_code['ì‹œë„ëª…_raw'].astype(str).str.strip()

        df_sido_code['ì‹œë„ëª…_std'] = df_sido_code['ì‹œë„ëª…_raw'].replace(sido_std_mapping, regex=True)

        print(f"âœ… ì‹œë„ ì½”ë“œ ë¡œë“œ ë° ì •ë¦¬ ì™„ë£Œ. (ì´ {len(df_sido_code)}ê°œ ì‹œë„ ì½”ë“œ)")

    except Exception as e:
        print(f"âŒ ì‹œë„ ì½”ë“œ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (ì‹œíŠ¸ëª… '{SIDO_SHEET}' í™•ì¸): {e}")
        df_sido_code = pd.DataFrame(columns=['ì‹œë„ëª…_std', 'sido_cd'])

    # 3. êµ¬êµ° ì½”ë“œ (Sheet 2) ë¡œë“œ ë° ì •ë¦¬
    try:
        df_gugun_code = pd.read_excel(CODE_FILE, sheet_name=GUGUN_SHEET, header=None)
        df_gugun_code = df_gugun_code.iloc[1:][[0, 1, 2]].copy()
        df_gugun_code.columns = ['ì‹œë„_raw', 'êµ¬êµ°ëª…_raw', 'gugun_cd']

        df_gugun_code['ì‹œë„_raw'] = df_gugun_code['ì‹œë„_raw'].ffill()
        df_gugun_code = df_gugun_code.dropna(subset=['gugun_cd'])
        df_gugun_code['gugun_cd'] = df_gugun_code['gugun_cd'].astype(str).str.strip()

        # ì‹œë„ëª… í‘œì¤€í™”
        df_gugun_code['ì‹œë„_std'] = df_gugun_code['ì‹œë„_raw'].replace(sido_std_mapping, regex=True).str.strip()

        # êµ¬êµ°ëª… í‘œì¤€í™”: ì½”ë“œ íŒŒì¼ì—ë„ í‘œì¤€í™” í•¨ìˆ˜ ì ìš©
        df_gugun_code['êµ¬êµ°ëª…_std'] = df_gugun_code['êµ¬êµ°ëª…_raw'].apply(standardize_gugun)

        print(f"âœ… êµ¬êµ° ì½”ë“œ ë¡œë“œ ë° ì •ë¦¬ ì™„ë£Œ. (ì´ {len(df_gugun_code)}ê°œ êµ¬êµ° ì½”ë“œ)")

    except Exception as e:
        print(f"âŒ êµ¬êµ° ì½”ë“œ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (ì‹œíŠ¸ëª… '{GUGUN_SHEET}' í™•ì¸): {e}")
        df_gugun_code = pd.DataFrame(columns=['ì‹œë„_std', 'êµ¬êµ°ëª…_std', 'gugun_cd'])


# -------------------------------------------------------------------------
# ë©”ì¸ ë°ì´í„°í”„ë ˆì„ í‘œì¤€í™” ë° ë³‘í•©
# -------------------------------------------------------------------------

if not df.empty:
    # 1. ë©”ì¸ ë°ì´í„°í”„ë ˆì„ (df)ì˜ ë³‘í•© í‚¤ í‘œì¤€í™”
    df['ì‹œë„ëª…_std'] = df['ì‹œë„ëª…'].replace(sido_std_mapping, regex=True).str.strip()

    # â­â­ ë©”ì¸ ë°ì´í„°í”„ë ˆì„ì˜ êµ¬êµ°ëª…ì— í‘œì¤€í™” í•¨ìˆ˜ ì ìš© (í•µì‹¬) â­â­
    df['êµ¬êµ°ëª…_std'] = df['êµ¬êµ°ëª…'].apply(standardize_gugun)

    print("âœ… ë©”ì¸ ë°ì´í„°í”„ë ˆì„ì˜ ë³‘í•© í‚¤ í‘œì¤€í™” ì™„ë£Œ.")

    # 2. ì‹œë„ ì½”ë“œ ë³‘í•© (ì´ì „ sido_cd ì»¬ëŸ¼ ì œê±° í›„)
    if not df_sido_code.empty:
        if 'sido_cd' in df.columns: df = df.drop(columns=['sido_cd'])
        df = pd.merge(df, df_sido_code[['ì‹œë„ëª…_std', 'sido_cd']], on='ì‹œë„ëª…_std', how='left')
        print("âœ… ì‹œë„ ì½”ë“œ ë³‘í•© ì™„ë£Œ. (í‚¤: ì‹œë„ëª…_std)")
    else:
        print("âš ï¸ ê²½ê³ : ì‹œë„ ì½”ë“œ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ë¡œ ì‹œë„ ì½”ë“œ ë³‘í•©ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
        df['sido_cd'] = np.nan

    # 3. êµ¬êµ° ì½”ë“œ ë³‘í•© (ì´ì „ gugun_cd ì»¬ëŸ¼ ë° ì„ì‹œ ì»¬ëŸ¼ ì œê±° í›„)
    if not df_gugun_code.empty:
        if 'gugun_cd' in df.columns: df = df.drop(columns=['gugun_cd'])
        if 'ì‹œë„_std' in df.columns: df = df.drop(columns=['ì‹œë„_std'])

        df = pd.merge(df, df_gugun_code[['ì‹œë„_std', 'êµ¬êµ°ëª…_std', 'gugun_cd']],
                     left_on=['ì‹œë„ëª…_std', 'êµ¬êµ°ëª…_std'],
                     right_on=['ì‹œë„_std', 'êµ¬êµ°ëª…_std'],
                     how='left')

        if 'ì‹œë„_std' in df.columns:
            df = df.drop(columns=['ì‹œë„_std'])

        print("âœ… êµ¬êµ° ì½”ë“œ ë³‘í•© ì™„ë£Œ. (í‚¤: ì‹œë„ëª…_std, êµ¬êµ°ëª…_std)")

        # 4. ê²°ê³¼ í™•ì¸
        print("\nâœ… ì½”ë“œ ë³‘í•© ì™„ë£Œ. ê²°ê³¼ DataFrame ìƒ˜í”Œ:")
        print(df[['ì‹œë„ëª…', 'êµ¬êµ°ëª…', 'ì‹œë„ëª…_std', 'êµ¬êµ°ëª…_std', 'sido_cd', 'gugun_cd']].head())

        missing_sido_cd = df['sido_cd'].isnull().sum()
        missing_gugun_cd = df['gugun_cd'].isnull().sum()

        print(f"\nğŸ’¡ ë³‘í•© í›„ í™•ì¸ ì‚¬í•­:")
        print(f" Â  - sido_cd ëˆ„ë½ ê°œìˆ˜: {missing_sido_cd}ê°œ")
        print(f" Â  - gugun_cd ëˆ„ë½ ê°œìˆ˜: {missing_gugun_cd}ê°œ")

        if missing_sido_cd > 0 or missing_gugun_cd > 0:
            print("âš ï¸ ê²½ê³ : í‘œì¤€í™” ë° ë””ë²„ê¹… í›„ì—ë„ ì¼ë¶€ ë§¤í•‘ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤. (ë°ì´í„° ë¶ˆì¼ì¹˜ ë°œìƒ ì§€ì  ë¶„ì„ í•„ìš”)")
            # 5. ëˆ„ë½ëœ ë°ì´í„°ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•œ ìƒ˜í”Œ ì¶œë ¥ (ë””ë²„ê¹…)
            print("\nâŒ ëˆ„ë½ëœ ë°ì´í„° 5ê°œ ìƒ˜í”Œ (ë””ë²„ê¹…ìš©):")
            # sido_cd ë˜ëŠ” gugun_cdê°€ ëˆ„ë½ëœ ë°ì´í„°
            print(df[df['sido_cd'].isnull() | df['gugun_cd'].isnull()][['ì‹œë„ëª…', 'êµ¬êµ°ëª…', 'ì‹œë„ëª…_std', 'êµ¬êµ°ëª…_std']].head())

        else:
            print("ğŸ‰ ëª¨ë“  ë°ì´í„°ì— ëŒ€í•´ sido_cd ë° gugun_cd ë§¤í•‘ ì„±ê³µ!")

        # 6. ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìœ„í•´ Part 4ì—ì„œ ì½”ë“œ ë³‘í•©ì´ ì™„ë£Œëœ dfë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
        df = df.drop(columns=['ì‹œë„ëª…_std', 'êµ¬êµ°ëª…_std'], errors='ignore')
        df.to_pickle("processed_part4_df.pkl")
        print("\nâœ… Part 4 ì™„ë£Œ. ì¤‘ê°„ ê²°ê³¼ê°€ 'processed_part4_df.pkl'ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
    else:
        print("âš ï¸ ê²½ê³ : êµ¬êµ° ì½”ë“œ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ë¡œ êµ¬êµ° ì½”ë“œ ë³‘í•©ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
else:
    print("âŒ ì¹˜ëª…ì  ì˜¤ë¥˜: ë©”ì¸ ë°ì´í„°í”„ë ˆì„(df)ì´ ë¡œë“œë˜ì§€ ì•Šì•„ Part 4ë¥¼ ì™„ë£Œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
# =================================================================

import pandas as pd
import geopandas as gpd
import json
import re
from IPython.display import HTML, display

# --- 1. íŒŒì¼ ê²½ë¡œ ì„¤ì • ---
# **ì‚¬ìš©ì íŒŒì¼ ê²½ë¡œë¡œ ìˆ˜ì •í•˜ì„¸ìš”**
# GeoJSON íŒŒì¼ ê²½ë¡œ (ì˜ˆ: ì‹œêµ°êµ¬ ê²½ê³„ ë°ì´í„°)
sig_geo_path = 'korea_geojson.json' # ì‚¬ìš©ì í™˜ê²½ì— ë§ëŠ” ì •í™•í•œ ê²½ë¡œì™€ íŒŒì¼ëª…ì„ ì‚¬ìš©í•˜ì„¸ìš”.
accident_csv_path = '19_24_drunk.csv'

# --- 2. ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬ ---

# ì‚¬ê³  ë°ì´í„° ë¡œë“œ (ë” ê°•ë ¥í•œ ì¸ì½”ë”© ì²˜ë¦¬: utf-8-sig -> cp949 ìˆœì°¨ ì‹œë„)
accident_df = pd.DataFrame()
try:
    print("ë°ì´í„° ë¡œë“œ ì‹œë„ (1/3): 'utf-8-sig' ì¸ì½”ë”©ìœ¼ë¡œ CSV ë¡œë“œ...")
    accident_df = pd.read_csv(accident_csv_path, encoding='utf-8-sig')
except UnicodeDecodeError:
    try:
        print("ë°ì´í„° ë¡œë“œ ì‹œë„ (2/3): 'utf-8-sig' ì‹¤íŒ¨. 'cp949' ì¸ì½”ë”©ìœ¼ë¡œ CSV ë¡œë“œ...")
        accident_df = pd.read_csv(accident_csv_path, encoding='cp949')
    except UnicodeDecodeError:
        print("âŒ ì¹˜ëª…ì  ì˜¤ë¥˜: ì‚¬ê³  ë°ì´í„° íŒŒì¼ì˜ ì¸ì½”ë”©ì„ í•´ì„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 'utf-8-sig'ì™€ 'cp949' ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
    except FileNotFoundError:
        print(f"âŒ ì¹˜ëª…ì  ì˜¤ë¥˜: ì‚¬ê³  ë°ì´í„° íŒŒì¼ '{accident_csv_path}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”.")
except FileNotFoundError:
    print(f"âŒ ì¹˜ëª…ì  ì˜¤ë¥˜: ì‚¬ê³  ë°ì´í„° íŒŒì¼ '{accident_csv_path}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”.")


if accident_df.empty:
    geojson_with_risk_scores = json.dumps({"type": "FeatureCollection", "features": []})
    point_data_for_html = json.dumps({'points': []})
    print("âš ï¸ ë°ì´í„° ì²˜ë¦¬ ì¤‘ë‹¨: ì‚¬ê³  ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ë¡œ ë¹ˆ ì§€ë„ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.")
else:
    print(f"âœ… ë°ì´í„° ë¡œë“œ ì„±ê³µ: ì´ {len(accident_df)}ê±´ì˜ ì‚¬ê³  ë°ì´í„°.")

    # í•„ìˆ˜ ì»¬ëŸ¼ ë¦¬ìŠ¤íŠ¸ (ì‹¤ì œ ë°ì´í„° í—¤ë”ì— ë§ê²Œ ìˆ˜ì •ë¨)
    required_cols = ['ì‹œë„ì‹œêµ°êµ¬ëª…', 'ì‚¬ê³ ê±´ìˆ˜', 'ì‚¬ìƒììˆ˜', 'ìœ„ë„', 'ê²½ë„', 'ì§€ì ëª…']

    # í•„ìˆ˜ ì»¬ëŸ¼ í™•ì¸ ë° ì¶”ì¶œ
    for col in required_cols:
        if col not in accident_df.columns:
            raise KeyError(f"âŒ ì˜¤ë¥˜: ì‚¬ê³  ë°ì´í„°ì— í•„ìˆ˜ ì»¬ëŸ¼ '{col}'ì´(ê°€) ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œ ë°ì´í„° í—¤ë”ë¥¼ í™•ì¸í•˜ì„¸ìš”.")

    accident_df = accident_df[required_cols].copy()
    accident_df['ì‚¬ê³ ê±´ìˆ˜'] = pd.to_numeric(accident_df['ì‚¬ê³ ê±´ìˆ˜'], errors='coerce').fillna(0).astype(int)

    # ì§€ë¦¬ ë°ì´í„° ë¡œë“œ (GeoPandas ì‚¬ìš©)
    try:
        print(f"ë°ì´í„° ë¡œë“œ ì‹œë„ (3/3): GeoJSON íŒŒì¼ ('{sig_geo_path}') ë¡œë“œ...")
        # GeoJSON íŒŒì¼ ë¡œë“œ. ì¸ì½”ë”© ë¬¸ì œ ë°©ì§€ë¥¼ ìœ„í•´ utf-8-sig ì‚¬ìš©
        gdf = gpd.read_file(sig_geo_path, encoding='utf-8-sig')
    except Exception as e:
        raise Exception(f"âŒ ì¹˜ëª…ì  ì˜¤ë¥˜: GeoJSON ë¡œë“œ ì‹¤íŒ¨. ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”: {sig_geo_path}. ì˜¤ë¥˜: {e}")

    # --- 3. ìœ„í—˜ ì ìˆ˜ ê³„ì‚° ë° GeoJSONì— ë³‘í•© ---

    # GeoJSON íŒŒì¼ì€ ë³´í†µ ì‹œ/êµ°/êµ¬ ì´ë¦„ë§Œ í¬í•¨í•˜ë¯€ë¡œ, ì‚¬ê³  ë°ì´í„°ì—ì„œ ì‹œ/ë„ ì´ë¦„ì„ ì œê±°í•˜ê³  ë§ˆì§€ë§‰ ì´ë¦„ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
    def extract_gugun_name(full_name):
        # ìˆ«ì ì œê±° ë° ê³µë°± ì œê±°
        clean_name = re.sub(r'\d+', '', full_name).strip()
        # ê³µë°±ìœ¼ë¡œ ë‚˜ëˆˆ ë’¤ ë§ˆì§€ë§‰ ìš”ì†Œ (ì‹œ, êµ°, êµ¬ ì´ë¦„)ë¥¼ ë°˜í™˜
        parts = clean_name.split()
        return parts[-1] if parts else clean_name

    accident_df['SIG_KOR_NM'] = accident_df['ì‹œë„ì‹œêµ°êµ¬ëª…'].apply(extract_gugun_name)

    # ì§€ì—­ë³„ ì´ ì‚¬ê³  ê±´ìˆ˜ ê³„ì‚° (ìœ„í—˜ ì ìˆ˜)
    risk_scores = accident_df.groupby('SIG_KOR_NM')['ì‚¬ê³ ê±´ìˆ˜'].sum().reset_index()
    risk_scores.rename(columns={'ì‚¬ê³ ê±´ìˆ˜': 'risk_score'}, inplace=True)

    # GeoDataFrameì— ìœ„í—˜ ì ìˆ˜ ë³‘í•© (left join)
    if 'SIG_KOR_NM' not in gdf.columns:
        print("âš ï¸ ê²½ê³ : GeoJSON íŒŒì¼ì— 'SIG_KOR_NM' ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. GeoJSON í—¤ë”ë¥¼ í™•ì¸í•˜ì—¬ ë³‘í•© í‚¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.")
        geojson_with_risk_scores = gdf.to_json()
    else:
        gdf_merged = gdf.merge(risk_scores, on='SIG_KOR_NM', how='left')
        gdf_merged['risk_score'] = gdf_merged['risk_score'].fillna(0) # ì‚¬ê³  ì—†ëŠ” ì§€ì—­ì€ 0ìœ¼ë¡œ ì±„ì›€
        geojson_with_risk_scores = gdf_merged.to_json()


    # --- 4. í¬ì¸íŠ¸ ë°ì´í„° ì¤€ë¹„ ---

    # ìœ„ë„/ê²½ë„ ì •ë³´ë¥¼ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
    point_data_list = accident_df[['ìœ„ë„', 'ê²½ë„', 'ì‚¬ê³ ê±´ìˆ˜', 'ì‚¬ìƒììˆ˜', 'ì§€ì ëª…']].to_dict('records')
    point_data_for_html = json.dumps({'points': point_data_list})

# --- 5. HTML í…œí”Œë¦¿ ë° ë°ì´í„° ì‚½ì… ---

# JSON ë°ì´í„°ë¥¼ JavaScript ë³€ìˆ˜ì— ì§ì ‘ ì‚½ì…í•  ìˆ˜ ìˆë„ë¡ ë¬¸ìì—´í™”
def escape_for_js_literal(data_str):
    data_str = data_str.replace('\\', '\\\\')
    data_str = data_str.replace("'", "\\'")
    return data_str

geojson_str = escape_for_js_literal(geojson_with_risk_scores)
point_data_str = escape_for_js_literal(point_data_for_html)

# HTML í…œí”Œë¦¿ (f-string ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•´ ëª¨ë“  ì¤‘ê´„í˜¸ëŠ” {{}}ë¡œ ì²˜ë¦¬ë¨)
html_template = f"""
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ìŒì£¼ìš´ì „ ì‚¬ê³  ë‹¤ë°œ ì§€ì—­ ìœ„í—˜ ì§€ë„</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Tailwind CSS (Aesthetics) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20n6n+A4+B0sP1H0/4P3+xQW966/p19O/T91/4w7/c0="
            crossorigin=""></script>

    <style>
        /* ê¸°ë³¸ í°íŠ¸ ì„¤ì • */
        body {{
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
        }}
        /* ì§€ë„ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #map {{
            height: 80vh; /* ë†’ì´ ìœ ì§€ */
            width: 100%;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            margin-top: 1.5rem;
        }}
        /* ë²”ë¡€ ë° ì •ë³´ì°½ ìŠ¤íƒ€ì¼ */
        .info {{
            padding: 10px 15px;
            font: 14px/18px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 0.5rem; /* rounded-lg */
        }}
        .legend {{
            line-height: 20px;
            color: #555;
        }}
        .legend i {{
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.9;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* ë²”ë¡€ ìƒ‰ìƒ ë¸”ë¡ì— ê·¸ë¦¼ì ì¶”ê°€ */
        }}
        .status-box {{
            padding: 12px;
            border-radius: 0.5rem;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 700;
            transition: background-color 0.3s;
            border: 1px solid;
        }}
        .leaflet-popup-content-wrapper {{
            border-radius: 0.5rem;
            padding: 0;
            line-height: 1.5;
        }}
        .leaflet-popup-content {{
            margin: 10px;
        }}
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto max-w-7xl">
        <div class="text-center mb-6 bg-white p-4 rounded-lg shadow-md">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-red-700">ğŸš¨ ìŒì£¼ìš´ì „ ì‚¬ê³  ìœ„í—˜ ì§€ì—­ ì§€ë„ ğŸº</h1>
            <p class="text-gray-600 mt-2 text-sm sm:text-base">ì§€ì—­ë³„ ì‚¬ê³  ê±´ìˆ˜ ê¸°ë°˜ ìœ„í—˜ë„ (ë©´ì ìƒ‰) ë° ê°œë³„ ì‚¬ê³  ì§€ì  (ì›í˜• ë§ˆì»¤) ì‹œê°í™”</p>
        </div>

        <div id="status-message" class="status-box border-blue-400 bg-blue-50 text-blue-800">
            ë°ì´í„° ë¡œë“œ ë° ì§€ë„ ì´ˆê¸°í™” ì¤‘...
        </div>

        <div id="map">
            <!-- Leaflet Map Will Be Rendered Here -->
        </div>
    </div>

    <script>
        // --- 1. Pythonì—ì„œ ì‚½ì…ëœ ë°ì´í„°ë¥¼ JavaScript ë³€ìˆ˜ì— í• ë‹¹ ---
        const MAP_DATA = JSON.parse('{geojson_str}');
        const POINT_DATA = JSON.parse('{point_data_str}');

        const TILE_URL = 'https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png';

        // DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        const statusMessage = document.getElementById('status-message');

        // Leaflet ë§µ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì €ì¥í•  ë³€ìˆ˜
        let map;
        let geoJsonLayer;

        // ìœ„í—˜ ì ìˆ˜ ìƒ‰ìƒì„ ê²°ì •í•˜ëŠ” í•¨ìˆ˜ (Choropleth Mapìš©)
        function getColor(d) {{
            // ì ìˆ˜ì— ë”°ë¼ 7ë‹¨ê³„ ìƒ‰ìƒ ì •ì˜ (ë¶‰ì€ ê³„ì—´)
            return d > 100 ? '#800026' :
                   d > 50  ? '#BD0026' :
                   d > 20  ? '#E31A1C' :
                   d > 10  ? '#FC4E2A' :
                   d > 5   ? '#FD8D3C' :
                   d > 0   ? '#FEB24C' :
                             '#FFEDA0'; // 0ì 
        }}

        // ì§€ë¦¬ì  íŠ¹ì„±(Feature)ì˜ ìŠ¤íƒ€ì¼ì„ ì§€ì •í•˜ëŠ” í•¨ìˆ˜
        function style(feature) {{
            // GeoJSONì— 'risk_score'ê°€ ì¶”ê°€ë˜ì–´ ìˆë‹¤ê³  ê°€ì •
            const risk = feature.properties.risk_score || 0;

            return {{
                fillColor: getColor(risk),
                weight: 1,
                opacity: 1,
                color: 'white',
                dashArray: '3',
                fillOpacity: 0.7
            }};
        }}

        // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ì´ë²¤íŠ¸ ì²˜ë¦¬ (í•˜ì´ë¼ì´íŠ¸)
        function highlightFeature(e) {{
            const layer = e.target;

            layer.setStyle({{
                weight: 5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.9
            }});

            // ğŸ’¥ ìˆ˜ì • 1: ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ í´ë¦¬ê³¤ì„ ë§¨ ì•ìœ¼ë¡œ ê°€ì ¸ì˜¤ëŠ” ì½”ë“œë¥¼ ì œê±°í–ˆìŠµë‹ˆë‹¤.
            // if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {{
            //     layer.bringToFront();
            // }}

            info.update(layer.feature.properties);
        }}

        // ë§ˆìš°ìŠ¤ ì•„ì›ƒ ì‹œ ì´ë²¤íŠ¸ ì²˜ë¦¬ (ì›ë˜ ìŠ¤íƒ€ì¼ë¡œ ë³µì›)
        function resetHighlight(e) {{
            if (geoJsonLayer) {{
                 geoJsonLayer.resetStyle(e.target);
            }}
            info.update();
        }}

        // ê° Featureì— ì´ë²¤íŠ¸ë¥¼ ë°”ì¸ë”©
        function onEachFeature(feature, layer) {{
            layer.on({{
                mouseover: highlightFeature,
                mouseout: resetHighlight,
                click: function(e) {{
                    const props = feature.properties;
                    // GeoJSONì— 'SIG_KOR_NM' ë˜ëŠ” 'NAME'ì´ ìˆë‹¤ê³  ê°€ì •
                    const name = props.SIG_KOR_NM || props.NAME || 'ì§€ì—­ëª… ì—†ìŒ';
                    const popupContent = `
                        <div class="p-2 font-sans">
                            <h4 class="text-base font-bold text-red-700 mb-1">${{name}}</h4>
                            <p class="text-sm">ìœ„í—˜ ì ìˆ˜ (ì‚¬ê³  ê±´ìˆ˜ í•©):
                                <span class="font-extrabold text-xl text-red-600">${{props.risk_score ? parseFloat(props.risk_score).toFixed(1) : '0'}}</span> ì 
                            </p>
                        </div>
                    `;
                    layer.bindPopup(popupContent).openPopup();
                }}
            }});
        }}


        // ê°œë³„ ì‚¬ê³  ì§€ì ì— ë§ˆì»¤ë¥¼ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜ (Point Marker)
        function addPointMarkers() {{
            statusMessage.innerHTML = 'ê°œë³„ ì‚¬ê³  ì§€ì  ë§ˆì»¤ ì¶”ê°€ ì¤‘...';

            // POINT_DATA ë³€ìˆ˜ë¥¼ ì§ì ‘ ì‚¬ìš©
            const points = POINT_DATA.points || [];

            const markers = points.map(point => {{
                const lat = parseFloat(point['ìœ„ë„']);
                const lng = parseFloat(point['ê²½ë„']);

                if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {{
                    return null;
                }}

                const accidentCount = parseInt(point['ì‚¬ê³ ê±´ìˆ˜'], 10) || 1;
                const radius = Math.log(accidentCount + 1) * 3 + 3;

                const markerColor = accidentCount > 10 ? '#4a148c' :
                                    accidentCount > 3 ? '#880e4f' :
                                                        '#ad1457';

                const marker = L.circleMarker([lat, lng], {{
                    radius: radius,
                    color: '#ffffff',
                    weight: 1,
                    opacity: 0.8,
                    fillColor: markerColor,
                    fillOpacity: 0.8
                }});

                // ë§ˆì»¤ì˜ í´ë¦­ ì´ë²¤íŠ¸ê°€ GeoJSONìœ¼ë¡œ ì „íŒŒë˜ëŠ” ê²ƒì„ ë§‰ìŒ (ì¶”ê°€ ì•ˆì •ì„±)
                marker.on('click', function(e) {{
                    L.DomEvent.stopPropagation(e);
                }});

                const popupContent = `
                    <div class="font-sans text-sm p-1">
                        <div class="font-extrabold text-base text-purple-800 text-center mb-1">
                            ${{point['ì§€ì ëª…'] || 'ì´ë¦„ ì—†ìŒ'}}
                        </div>
                        <div class="text-xs text-gray-700">
                            ì‚¬ê³  ê±´ìˆ˜: <span class="font-semibold text-purple-600">${{point['ì‚¬ê³ ê±´ìˆ˜']}}</span> ê±´
                        </div>
                        <div class="text-xs text-gray-600">
                            ì‚¬ìƒì ìˆ˜: <span class="font-semibold">${{point['ì‚¬ìƒììˆ˜']}}</span> ëª…
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, {{ closeButton: true, maxWidth: 250 }});

                marker.bindTooltip(`ì‚¬ê³  ${{point['ì‚¬ê³ ê±´ìˆ˜']}}ê±´ (${{point['ì§€ì ëª…']}})`, {{
                    permanent: false,
                    direction: 'top',
                    offset: [0, -radius]
                }});

                return marker;
            }}).filter(m => m !== null);

            const markerLayer = L.layerGroup(markers);
            markerLayer.addTo(map);

            console.log(`âœ… Point Markers Added: ì´ ${{markers.length}}ê°œ ìœ íš¨ ì§€ì .`);
        }}

        // ì •ë³´ì°½ (Info Control) ì •ì˜ ë° ì´ˆê¸°í™”
        let info = L.control({{ position: 'topright' }});

        info.onAdd = function (map) {{
            this._div = L.DomUtil.create('div', 'info');
            this.update();
            return this._div;
        }};

        info.update = function (props) {{
            const name = props ? (props.SIG_KOR_NM || props.NAME || 'ì•Œ ìˆ˜ ì—†ëŠ” ì§€ì—­') : 'ì§€ì—­ì„ ì˜¬ë ¤ë³´ì„¸ìš”';
            const risk = props && props.risk_score !== undefined ? parseFloat(props.risk_score).toFixed(1) : 'N/A';

            this._div.innerHTML = '<h4>ìŒì£¼ìš´ì „ ì‚¬ê³  ìœ„í—˜ ì ìˆ˜ (ë©´ì )</h4>' +
                (props ?
                '<b>' + name + '</b><br />' + 'ìœ„í—˜ ì ìˆ˜: <b>' + risk + '</b> ì '
                : 'ì§€ì—­ì„ ì§€ë„ ìœ„ì—ì„œ ì„ íƒí•˜ì„¸ìš”');
        }};

        // ë²”ë¡€ ì¶”ê°€ í•¨ìˆ˜
        function addLegend() {{
            const legend = L.control({{ position: 'bottomright' }});

            legend.onAdd = function (map) {{
                const div = L.DomUtil.create('div', 'info legend');
                const grades = [0, 5, 10, 20, 50, 100];
                const labels = ['<strong>ì‚¬ê³  ìœ„í—˜ ì ìˆ˜ (ë©´ì )</strong>'];
                let from, to;

                for (let i = 0; i < grades.length; i++) {{
                    from = grades[i];
                    to = grades[i + 1];

                    labels.push(
                        '<i style="background:' + getColor(from + 1) + '"></i> ' +
                        from + (to ? (to === 100 ? '&ndash;100' : '&ndash;' + to) : '+'));
                }}

                labels.push('<br><strong>ê°œë³„ ì§€ì  ë§ˆì»¤ (ì›)</strong>');
                labels.push('<i style="background:#4a148c; border: 1px solid #fff;"></i> ì‚¬ê³  10ê±´ ì´ìƒ');
                labels.push('<i style="background:#880e4f; border: 1px solid #fff;"></i> ì‚¬ê³  4~10ê±´');
                labels.push('<i style="background:#ad1457; border: 1px solid #fff;"></i> ì‚¬ê³  1~3ê±´');


                div.innerHTML = labels.join('<br>');
                return div;
            }};

            legend.addTo(map);
        }}

        // ë§µ ë°ì´í„° ë¡œë“œ ë° ì²˜ë¦¬ ë©”ì¸ í•¨ìˆ˜
        function loadAndDisplayMapData() {{
            console.log("â­ ì§€ì˜¤ë§µ ì´ˆê¸°í™” í•¨ìˆ˜ ì‹œì‘");

            map = L.map('map').setView([36.5, 127.8], 7);

            L.tileLayer(TILE_URL, {{
                maxZoom: 18,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }}).addTo(map);

            info.addTo(map);

            try {{
                // 1. GeoJSON (Choropleth Map) ë°ì´í„° ë¡œë“œ (Pythonì—ì„œ ì‚½ì…ëœ ë³€ìˆ˜ ì‚¬ìš©)
                statusMessage.innerHTML = 'GeoJSON ë°ì´í„° ë¡œë“œ ë° Choropleth ë§µ ìƒì„± ì¤‘...';

                const geoJsonData = MAP_DATA;

                if (!geoJsonData || geoJsonData.type !== 'FeatureCollection') {{
                    throw new Error("GeoJSON ë°ì´í„°ê°€ ìœ íš¨í•œ 'FeatureCollection' í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. Python ì½”ë“œë¥¼ í™•ì¸í•˜ì„¸ìš”.");
                }}

                // 2. GeoJSON ë ˆì´ì–´ ì¶”ê°€
                geoJsonLayer = L.geoJson(geoJsonData, {{
                    style: style,
                    onEachFeature: onEachFeature
                }}).addTo(map);

                // GeoJSON ë ˆì´ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ê°€ì¥ ì•„ë˜ë¡œ ë³´ëƒ…ë‹ˆë‹¤. (ê¸°ë³¸ ì„¤ì •)
                geoJsonLayer.bringToBack();

                try {{
                    map.fitBounds(geoJsonLayer.getBounds());
                }} catch (e) {{
                    console.warn("ì§€ë„ ê²½ê³„ ì„¤ì • ì‹¤íŒ¨. ê¸°ë³¸ ë·°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.", e);
                }}
                console.log("âœ… GeoJSON Choropleth ë§µ ìƒì„± ì™„ë£Œ.");


                // 3. ê°œë³„ ì§€ì  ë§ˆì»¤ ì¶”ê°€ (Point Marker)
                // ë§ˆì»¤ëŠ” ì´ ë ˆì´ì–´ë³´ë‹¤ í›„ì— ì¶”ê°€ë˜ë¯€ë¡œ ìë™ìœ¼ë¡œ ìœ„ì— ìœ„ì¹˜í•˜ë©°,
                // GeoJSONì˜ bringToFront ê¸°ëŠ¥ì´ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ ë§ˆì»¤ í´ë¦­ì´ ë°©í•´ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.
                addPointMarkers();


                // 4. ë²”ë¡€ ì¶”ê°€
                addLegend();

                // 5. ìµœì¢… ìƒíƒœ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
                statusMessage.style.backgroundColor = '#d1fae5';
                statusMessage.style.borderColor = '#6ee7b7';
                statusMessage.style.color = '#065f46';
                statusMessage.innerHTML = 'ğŸ‰ ì§€ë„ ì‹œê°í™” ì™„ë£Œ! ë§ˆìš°ìŠ¤ë¥¼ ì§€ì—­ì— ì˜¬ë ¤ë³´ì„¸ìš”.';

            }} catch (error) {{
                console.error("âŒ ë§µ ë°ì´í„° ë¡œë“œ ë˜ëŠ” ë§µ í‘œì‹œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
                statusMessage.style.backgroundColor = '#fee2e2';
                statusMessage.style.borderColor = '#fca5a5';
                statusMessage.style.color = '#991b1b';
                statusMessage.innerHTML = 'âŒ ì˜¤ë¥˜: ì§€ë„ ì‹œê°í™” ì‹¤íŒ¨. ìƒì„¸ ì˜¤ë¥˜: ' + error.message;
            }}
        }}

        // Colab í™˜ê²½ ìµœì í™”ë¥¼ ìœ„í•œ ì§€ì—° ì—†ëŠ” ì¦‰ì‹œ ì‹¤í–‰
        setTimeout(loadAndDisplayMapData, 0);
    </script>
</body>
</html>
"""

display(HTML(html_template))